#include "contiki.h"
#include "contiki-net.h"
#include "coap-observe-client.h"
#include "coap-blocking-api.h"
#include "sys/node-id.h"
#include "sys/log.h"

#include "datatypes.h"
#include "utility.h"
#include "custom-schedule.h"

#define LOG_MODULE "Client"
#define LOG_LEVEL LOG_LEVEL_DBG
#define NR_OF_CAN_NODES 50

/*---------------------------------------------------------------------------*/
/* Defined in C++ code */
extern uint8_t init_can_bus(uint64_t id, void (*scan_callback) (scan_data_msg_t, uint64_t), void (*product_update_callback) (unsigned long, uint64_t), uint64_t cluster_id);
extern uint8_t add_node(uint64_t id, void (*scan_callback) (scan_data_msg_t, uint64_t), void (*product_update_callback) (unsigned long, uint64_t));
extern uint8_t remove_node(uint64_t  id);
extern void send_can_message(CAN_command command, uint64_t target_node, CAN_data_t payload);
extern float simulate_can_bus();
extern void set_product_id(uint64_t node_id, unsigned long product_id);
extern void update_visualization(int clock);
/*---------------------------------------------------------------------------*/

#define TOGGLE_INTERVAL 10

PROCESS(client, "Client process with customer scan");
AUTOSTART_PROCESSES(&client);

static coap_observee_t *obs;
typedef struct {
    uint64_t calling_node;
    scan_data_t scan;
} scan_submission;
typedef struct {
    uint64_t calling_node;
    unsigned long product_id;
} product_update_request;

#define MAX_SCANS 50
typedef struct {
    scan_submission scans[MAX_SCANS];
    int len;
} scan_submissions;
#define MAX_REQUESTS 50
typedef struct {
    product_update_request requests[MAX_REQUESTS];
    int len;
} product_update_requests;



void scan_handler(coap_message_t *response) {
    if (response == NULL) {
        LOG_ERR("Scan request timed out\n");
    }
}
 
void query_handler(coap_message_t *response) {
    if (response == NULL) {
        LOG_ERR("Query request timed out\n");
        return;
    }

    product_t product = *(product_t*) response->payload;
    LOG_INFO("Query ID %lu: %s, price: %hu cents\n", product.id, product.description, product.price);
}

void notification_callback(coap_observee_t *subject, void *notification, coap_notification_flag_t flag) {
    int len = 0;
    const uint8_t *payload = NULL;

    LOG_INFO("Notification on URI: %s\n", subject->url);
    if (notification) {
        len = coap_get_payload(notification, &payload);
    }
    switch (flag) {
        case NOTIFICATION_OK:
        case OBSERVE_OK:
            LOG_INFO("OK: %*s\n", len, (char *) payload);
            break;
        case OBSERVE_NOT_SUPPORTED:
        case ERROR_RESPONSE_CODE:
        case NO_REPLY_FROM_SERVER:
            // TODO: More descriptive log message
            LOG_ERR("Something went wrong: %d\n", flag);
            obs = NULL;
            break;
    }
}

void scan_callback(scan_data_msg_t data, uint64_t calling_node) {
    unsigned long customer_id = data.customer_id;
    unsigned long long product_id = data.product_id;
    printf("Data: %ld, %lld. Generated by NODE#%ld\n", customer_id, product_id, calling_node);
    
    scan_submissions[scans.len] = { 
        calling_node, 
        {
            data.customer_id;
            data.product_id;
            1;
            (scan_type_t) ADD;
        }
    };
    scans.len++;
    // TODO, remove this and replace with actual method call upon receiving in client node.
    CAN_data_t msg_data;
    msg_data.empty = true;
    // printf("<-- THIS WOULD BE A NETWORK CALL TO SUBMIT SCAN -->\n");
    send_can_message(SCAN_ACK, calling_node, msg_data);
}

void product_update_callback(unsigned long product_id, uint64_t calling_node) {
    printf("NODE#%ld displaying product %ld requests updated information.\n", calling_node, product_id);
    unsigned short price = 2 * product_id + 1;
    CAN_data_t msg_data;
    msg_data.product_info = (product_info_msg_t) {
        product_id,
        price,
        "",
        PRODUCT_DESCRIPT_LEN
    };
    snprintf(msg_data.product_info.product_name, PRODUCT_DESCRIPT_LEN, "Product_%ld", product_id);
    printf("<-- THIS WOULD BE A NETWORK CALL TO FETCH DATA -->\n");
    send_can_message(PRODUCT_UPDATE, calling_node, msg_data);
}


PROCESS_THREAD(client, ev, data) {
    static struct etimer timer;
    coap_endpoint_t server_ep;
    uip_ipaddr_t root;
    coap_message_t request;

    PROCESS_BEGIN();

    initialize_tsch_schedule();
    int can_started = init_can_bus(NR_OF_CAN_NODES, &scan_callback, &product_update_callback);

    etimer_set(&timer, TOGGLE_INTERVAL * node_id * CLOCK_SECOND);

    while (1) {
        PROCESS_WAIT_EVENT_UNTIL(etimer_expired(&timer));
        float time_to_sleep = simulate_can_bus();
        printf("Simulated CAN bus, %f seconds until next message\n", time_to_sleep);
        etimer_set(&timer, time_to_sleep * CLOCK_SECOND);
        update_visualization(clock_time());

        if (!NETSTACK_ROUTING.node_is_reachable() || !NETSTACK_ROUTING.get_root_ipaddr(&root)) {
            obs = NULL;
            continue;
        }

        // Convert root IPv6 address to string
        char ip[UIPLIB_IPV6_MAX_STR_LEN];
        uiplib_ipaddr_snprint(ip, sizeof(ip), &root);

        coap_endpoint_parse(ip, strlen(ip), &server_ep);

        if (obs == NULL) {
            obs = coap_obs_request_registration(&server_ep, UPDATE_URI, notification_callback, NULL);
        }

        // If even node ID, send scans
        if (node_id % 2 == 0) {
            // Create payload for a scan for product id <node_id * 10000> and client id <node_id> and ADD 500 of the item
            scan_data_t scan = {
                node_id,
                node_id,
                500,
                0
            };

            request = coap_create_request(COAP_POST, SCAN_URI, COAP_TYPE_CON, &scan, sizeof(scan));

            // Send
            COAP_BLOCKING_REQUEST(&server_ep, &request, scan_handler);
        } else {
            ean13_t product_id = node_id;
            request = coap_create_request(COAP_GET, QUERY_URI, COAP_TYPE_CON, &product_id, sizeof(product_id));

            // Send :3
            COAP_BLOCKING_REQUEST(&server_ep, &request, query_handler);
        }

    }

    PROCESS_END();
}





