#include <stdio.h>
#include "contiki.h"
#include "contiki-net.h"
#include "coap-engine.h"
#include "coap-blocking-api.h"
#include "sys/node-id.h"
#include "sys/etimer.h"

#include "../../libraries/CAN-sim/shared/can-commands.h"
#include "../shared/coap/coap-datatypes.h"
#include "../shared/custom-schedule.h"

//TODO: Set all below definitions to more appropriate locations
#define NR_OF_CAN_NODES 16

/*---------------------------------------------------------------------------*/
/* Defined in C++ code */
extern uint8_t init_can_bus(uint64_t nr_of_nodes, void (*scan_callback) (scan_data_msg_t, uint64_t), void (*product_update_callback) (unsigned long, uint64_t), uint64_t node_id);
extern uint8_t add_node(uint64_t id, void (*scan_callback) (scan_data_msg_t, uint64_t), void (*product_update_callback) (unsigned long, uint64_t));
extern uint8_t remove_node(uint64_t  id);
extern void send_can_message(CAN_command command, uint64_t target_node, CAN_data_t payload);
extern float simulate_can_bus();
extern void set_product_id(uint64_t node_id, unsigned long product_id);
extern void update_visualization(int clock);
/*---------------------------------------------------------------------------*/

int sendcount = 0;

void scan_callback(scan_data_msg_t data, uint64_t calling_node) {
    unsigned long customer_id = data.customer_id;
    unsigned long long product_id = data.product_id;
    printf("Data: %ld, %lld. Generated by NODE#%ld\n", customer_id, product_id, calling_node);
    sendcount++;
    // TODO, remove this and replace with actual method call upon receiving in client node.
    CAN_data_t msg_data;
    msg_data.empty = true;
    // printf("<-- THIS WOULD BE A NETWORK CALL TO SUBMIT SCAN -->\n");
    send_can_message(SCAN_ACK, calling_node, msg_data);
}

void product_update_callback(unsigned long product_id, uint64_t calling_node) {
    printf("NODE#%ld displaying product %ld requests updated information.\n", calling_node, product_id);
    unsigned short price = 2 * product_id + 1;
    CAN_data_t msg_data;
    msg_data.product_info = (product_info_msg_t) {
        product_id,
        price,
        "",
        PRODUCT_DESCRIPT_LEN
    };
    snprintf(msg_data.product_info.product_name, PRODUCT_DESCRIPT_LEN, "Product_%ld", product_id);
    printf("<-- THIS WOULD BE A NETWORK CALL TO FETCH DATA -->\n");
    send_can_message(PRODUCT_UPDATE, calling_node, msg_data);
}

//COAP NODE CODE

PROCESS(client_process_v1b, "client process with customer scan");
AUTOSTART_PROCESSES(&client_process_v1b);

static struct etimer et;

void client_chunk_handler(coap_message_t* response)
{
    const uint8_t* chunk;

    if (response == NULL) {
        puts("Request timed out");
        return;
    }

    int len = coap_get_payload(response, &chunk);

    printf("|%.*s", len, (char*)chunk);
}

////start of process

PROCESS_THREAD(client_process_v1b, ev, data)
{
    coap_endpoint_t server_ep; //defines server ip --> mke sure that server in cooja uses the ones defined above
    uip_ipaddr_t root;

    PROCESS_BEGIN();

    initialize_tsch_schedule();

    static coap_message_t request[1];      //defines blank request as pointer
  
    // Initialize CAN bus for this node, this will dictate the frequency and contents of db requests, as well as ACK delays
    int res = init_can_bus(NR_OF_CAN_NODES, &scan_callback, &product_update_callback, node_id);
    printf("Initialized CAN bus: %d\n", res);

    while (1) {
        if (NETSTACK_ROUTING.node_is_reachable() && NETSTACK_ROUTING.get_root_ipaddr(&root)) {
            // Convert root IPv6 address to string
            char ip[UIPLIB_IPV6_MAX_STR_LEN];
            uiplib_ipaddr_snprint(ip, sizeof(ip), &root);

            coap_endpoint_parse(ip, strlen(ip), &server_ep);


            /* prepare request, TID is set by COAP_BLOCKING_REQUEST() */
            coap_init_message(request, COAP_TYPE_CON, COAP_POST, 0); //prepare
            coap_set_header_uri_path(request, "test/scan"); //we'll poll the "product" ressource (at test/hello until i can figure out why any other uri doenst work)

            scan_data_coap_t scan; // a scan
            //lets create a few database access commands (order 500 cigarettes)
            sprintf(scan.customer_id, "%d", node_id * 55); //arbitrary
            sprintf(scan.product_id, "%d", node_id * 100000);  //ID for cigarettes
            sprintf(scan.quantity, "%d", 500); // 500
            sprintf(scan.command, "%d", 0); //ADD to inventory

            char outputmsg[TX_LEN_POST]; //we'll define a buffer containing text corresponding to the product information request --> for now can only realistically send text through coap

            sprintf(outputmsg, "%s%s%s%s%s%s%s", scan.customer_id, TRANSX_SEP, scan.product_id, TRANSX_SEP,
                        scan.quantity, TRANSX_SEP,
                        scan.command); //creating string containing ID:data (data currently blank)
            //printf("%s\n",outputmsg);
            coap_set_payload(request, (char *) &outputmsg,
                                 sizeof(outputmsg) - 1); //set the struct to be the payload
            COAP_BLOCKING_REQUEST(&server_ep, request, client_chunk_handler); //send to server

            //printf("\n--Done--\n");
            float time_to_sleep = simulate_can_bus();
            // printf("Simulated CAN bus, %f seconds until next message\n", time_to_sleep);
            etimer_set(&et, time_to_sleep * CLOCK_SECOND);
            // float time = ((float)clock_time() - t_0)/1000.0;
            // float msgpersec = sendcount/time;
            // printf("Current load = %f msg/s at clock time: %f\n", msgpersec, time);
            update_visualization(clock_time());
        } else {
            printf("Sleeping\n");
            etimer_set(&et, 1 * CLOCK_SECOND);
        }
        PROCESS_WAIT_EVENT_UNTIL(etimer_expired(&et));
    }

    PROCESS_END();
}






