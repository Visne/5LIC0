#include "contiki.h"
#include "contiki-net.h"
#include "coap-observe-client.h"
#include "coap-blocking-api.h"
#include "sys/node-id.h"
<<<<<<< HEAD
#include "sys/log.h"
=======
#include "sys/etimer.h"
>>>>>>> 316b1b2a1607290622eabc65a63de9aa246281df

<<<<<<< Updated upstream
#include "datatypes.h"
#include "utility.h"
#include "custom-schedule.h"
=======
#include "../../libraries/CAN-sim/shared/can-commands.h"
#include "../shared/coap/coap-datatypes.h"
#include "../shared/coap/utility.h"
#include "../shared/custom-schedule.h"
>>>>>>> Stashed changes

<<<<<<< HEAD
#define LOG_MODULE "Client"
#define LOG_LEVEL LOG_LEVEL_DBG
=======
//TODO: Set all below definitions to more appropriate locations
#define NR_OF_CAN_NODES 16

/*---------------------------------------------------------------------------*/
/* Defined in C++ code */
extern uint8_t init_can_bus(uint64_t nr_of_nodes, void (*scan_callback) (scan_data_msg_t, uint64_t), void (*product_update_callback) (unsigned long, uint64_t), uint64_t node_id);
extern uint8_t add_node(uint64_t id, void (*scan_callback) (scan_data_msg_t, uint64_t), void (*product_update_callback) (unsigned long, uint64_t));
extern uint8_t remove_node(uint64_t  id);
extern void send_can_message(CAN_command command, uint64_t target_node, CAN_data_t payload);
extern float simulate_can_bus();
extern void set_product_id(uint64_t node_id, unsigned long product_id);
extern void update_visualization(int clock);
/*---------------------------------------------------------------------------*/

int sendcount = 0;

void scan_callback(scan_data_msg_t data, uint64_t calling_node) {
    unsigned long customer_id = data.customer_id;
    unsigned long long product_id = data.product_id;
    printf("Data: %ld, %lld. Generated by NODE#%ld\n", customer_id, product_id, calling_node);
    sendcount++;
    // TODO, remove this and replace with actual method call upon receiving in client node.
    CAN_data_t msg_data;
    msg_data.empty = true;
    // printf("<-- THIS WOULD BE A NETWORK CALL TO SUBMIT SCAN -->\n");
    send_can_message(SCAN_ACK, calling_node, msg_data);
}

void product_update_callback(unsigned long product_id, uint64_t calling_node) {
    printf("NODE#%ld displaying product %ld requests updated information.\n", calling_node, product_id);
    unsigned short price = 2 * product_id + 1;
    CAN_data_t msg_data;
    msg_data.product_info = (product_info_msg_t) {
        product_id,
        price,
        "",
        PRODUCT_DESCRIPT_LEN
    };
    snprintf(msg_data.product_info.product_name, PRODUCT_DESCRIPT_LEN, "Product_%ld", product_id);
    printf("<-- THIS WOULD BE A NETWORK CALL TO FETCH DATA -->\n");
    send_can_message(PRODUCT_UPDATE, calling_node, msg_data);
}

//COAP NODE CODE

PROCESS(client_process_v1b, "client process with customer scan");
AUTOSTART_PROCESSES(&client_process_v1b);
>>>>>>> 316b1b2a1607290622eabc65a63de9aa246281df

PROCESS(client, "Client process with customer scan");
AUTOSTART_PROCESSES(&client);

<<<<<<< HEAD
void scan_handler(coap_message_t *response) {
<<<<<<< Updated upstream
=======
    const uint8_t *chunk;
=======
void client_chunk_handler(coap_message_t* response)
{
    const uint8_t* chunk;
>>>>>>> 316b1b2a1607290622eabc65a63de9aa246281df

>>>>>>> Stashed changes
    if (response == NULL) {
        LOG_ERR("Scan request timed out\n");
    }
}

void query_handler(coap_message_t *response) {
    if (response == NULL) {
        LOG_ERR("Query request timed out\n");
        return;
    }

    product_info_t product = *(product_info_t*) response->payload;
    LOG_INFO("Query: %s (ID: %lu, price: %hu cents)\n", product.product_description, product.product_id, product.product_price);
}

void notification_callback(coap_observee_t *subject, void *notification, coap_notification_flag_t flag) {
    // FIXME: For whatever reason this function gets called even when the notification happens on another endpoint

    //    int len = 0;
    //    const uint8_t *payload = NULL;

    //LOG_INFO("Notification on URI: %s\n", subject->url);
    if (notification) {
        //len = coap_get_payload(notification, &payload);
    }
    switch (flag) {
        case NOTIFICATION_OK:
        case OBSERVE_OK:
            //LOG_INFO("OK: %*s\n", len, (char *) payload);
            break;
        case OBSERVE_NOT_SUPPORTED:
        case ERROR_RESPONSE_CODE:
        case NO_REPLY_FROM_SERVER:
            LOG_ERR("%d\n", flag);
            break;
    }
}

PROCESS_THREAD(client, ev, data) {
    static struct etimer timer;
    coap_endpoint_t server_ep;
    uip_ipaddr_t root;
    coap_message_t request;

    PROCESS_BEGIN();

    initialize_tsch_schedule();

<<<<<<< HEAD
    etimer_set(&timer, TOGGLE_INTERVAL * node_id * CLOCK_SECOND);

    while (1) {
        PROCESS_WAIT_EVENT_UNTIL(etimer_expired(&timer));
        etimer_reset(&timer);

        if (!NETSTACK_ROUTING.node_is_reachable() || !NETSTACK_ROUTING.get_root_ipaddr(&root)) {
            continue;
        }

        // Convert root IPv6 address to string
        char ip[UIPLIB_IPV6_MAX_STR_LEN];
        uiplib_ipaddr_snprint(ip, sizeof(ip), &root);

        coap_endpoint_parse(ip, strlen(ip), &server_ep);

        coap_obs_request_registration(&server_ep, UPDATE_URI, notification_callback, NULL);

        // If even node ID, send scans
        if (node_id % 2 == 0) {
            // Create payload for a scan for product id <node_id * 10000> and client id <node_id> and ADD 500 of the item
            scan_data_t scan = {
                node_id,
                node_id,
                500,
                0
            };

            request = coap_create_request(COAP_POST, SCAN_URI, COAP_TYPE_CON, &scan, sizeof(scan));

            // Send
            COAP_BLOCKING_REQUEST(&server_ep, &request, scan_handler);
        } else {
            // Create payload for a product info query for product id <node_id * 10000>
            req_product_data_t product;
            product.product_id = node_id;
            snprintf(product.blankbuffer, sizeof(product.blankbuffer), "Query info"); //can be changed depending on what we need

            request = coap_create_request(COAP_GET, QUERY_URI, COAP_TYPE_CON, &product, sizeof(product));

            // Send :3
            COAP_BLOCKING_REQUEST(&server_ep, &request, query_handler);
        }

=======
    static coap_message_t request[1];      //defines blank request as pointer
  
    // Initialize CAN bus for this node, this will dictate the frequency and contents of db requests, as well as ACK delays
    int res = init_can_bus(NR_OF_CAN_NODES, &scan_callback, &product_update_callback, node_id);
    printf("Initialized CAN bus: %d\n", res);

    while (1) {
        if (NETSTACK_ROUTING.node_is_reachable() && NETSTACK_ROUTING.get_root_ipaddr(&root)) {
            // Convert root IPv6 address to string
            char ip[UIPLIB_IPV6_MAX_STR_LEN];
            uiplib_ipaddr_snprint(ip, sizeof(ip), &root);

            coap_endpoint_parse(ip, strlen(ip), &server_ep);


            /* prepare request, TID is set by COAP_BLOCKING_REQUEST() */
            coap_init_message(request, COAP_TYPE_CON, COAP_POST, 0); //prepare
            coap_set_header_uri_path(request, "test/scan"); //we'll poll the "product" ressource (at test/hello until i can figure out why any other uri doenst work)

            scan_data_coap_t scan; // a scan
            //lets create a few database access commands (order 500 cigarettes)
            sprintf(scan.customer_id, "%d", node_id * 55); //arbitrary
            sprintf(scan.product_id, "%d", node_id * 100000);  //ID for cigarettes
            sprintf(scan.quantity, "%d", 500); // 500
            sprintf(scan.command, "%d", 0); //ADD to inventory

            char outputmsg[TX_LEN_POST]; //we'll define a buffer containing text corresponding to the product information request --> for now can only realistically send text through coap

            sprintf(outputmsg, "%s%s%s%s%s%s%s", scan.customer_id, TRANSX_SEP, scan.product_id, TRANSX_SEP,
                        scan.quantity, TRANSX_SEP,
                        scan.command); //creating string containing ID:data (data currently blank)
            //printf("%s\n",outputmsg);
            coap_set_payload(request, (char *) &outputmsg,
                                 sizeof(outputmsg) - 1); //set the struct to be the payload
            COAP_BLOCKING_REQUEST(&server_ep, request, client_chunk_handler); //send to server

            //printf("\n--Done--\n");
            float time_to_sleep = simulate_can_bus();
            // printf("Simulated CAN bus, %f seconds until next message\n", time_to_sleep);
            etimer_set(&et, time_to_sleep * CLOCK_SECOND);
            // float time = ((float)clock_time() - t_0)/1000.0;
            // float msgpersec = sendcount/time;
            // printf("Current load = %f msg/s at clock time: %f\n", msgpersec, time);
            update_visualization(clock_time());
        } else {
            printf("Sleeping\n");
            etimer_set(&et, 1 * CLOCK_SECOND);
        }
        PROCESS_WAIT_EVENT_UNTIL(etimer_expired(&et));
>>>>>>> 316b1b2a1607290622eabc65a63de9aa246281df
    }

    PROCESS_END();
}






